%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 4.0 (March 21, 2022)
%
% This template originates from:
% https://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@latextemplates.com)
% Linux and Unix Users Group at Virginia Tech Wiki
%
% License:
% CC BY-NC-SA 4.0 (https://creativecommons.org/licenses/by-nc-sa/4.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
	a4paper, % Paper size, specify a4paper (A4) or letterpaper (US letter)
	10pt, % Default font size, specify 10pt, 11pt or 12pt
]{CSUniSchoolLabReport}


\addbibresource{sample.bib} % Bibliography file (located in the same folder as the template)

%----------------------------------------------------------------------------------------
%	REPORT INFORMATION
%----------------------------------------------------------------------------------------

\title{MA-CSEL \\ Conception système Embarqué Linux \\ Mini-Projet } % Report title

\author{Kirill \textsc{Goundiaev} \& Tanguy \textsc{Dietrich}} % Author name(s), add additional authors like: '\& James \textsc{Smith}'

\fancyhead[RE,LO]{Kirill Goundiaev \& Tanguy Dietrich}
\fancyhead[CE,CO]{\today}
\fancyhead[LE,RO]{MA-CSEL}

\fancyfoot[RE,LO]{MSE}
\fancyfoot[CE,CO]{\thepage} % this dicard page number dont touch
\fancyfoot[LE,RO]{HES-SO}
\date{\today} % Date of the report


% add image on the left top corner
% Definition of \maketitle
\makeatletter         
\def\@maketitle{
\raggedright
% \includegraphics[width = 60mm]{Figures/MSE.png}\\[8ex]
\includegraphics[width = 180mm]{Figures/ImageTitle.png}\\[8ex]
\begin{center}{}
{\Huge \@title }\\[4ex] 
{\Large  \@author}\\[4ex] 
\@date\\[8ex]
% \includegraphics[width = 40mm]{Figures/HESSO.png}
\end{center}}
\makeatother

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert the title, author and date using the information specified above

% add an image
\begin{figure}[H] % Example image
\center{\includegraphics[width=0.35\linewidth]{EMbeddedLinuxLogo}}
% \caption{Example image.}
\label{fig:speciation}
\end{figure}


%  to make a guard page
\newpage

% generate the summary table
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{Introduction}
Le projet est composé de 2 parties : \\
\begin{itemize}
	\item Un module kernel qui permet de controler la frequence du processeur, et de changer le mode de fonctionnement du module kernel. Et il met a disposition les informations sur la temperature du CPU.
	\item Un daemon qui permet d'afficher les informations sur l'ecran, et de controler le module kernel.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MODULE KERNEL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module Kernel}\label{ModuleKernel}
Ce module kernel a pour but de gérer le refroidissement de notre système embarqué, qui est simulé par le clignotement d'une LED. Le module propose deux modes de fonctionnement :
\begin{itemize}
	\item Manuel : L'utilisateur peut choisir la fréquence de clignotement de la LED.
	\item Automatique : La fréquence de clignotement de la LED est calculée en fonction de la température du microprocesseur.
\end{itemize}

Le module met à disposition une interface de contrôle à travers $sysfs$ permettant de modifier le mode de fonctionnement, la fréquence de la Modulation de largeur d'impulsion (PWM) et de lire la température du microprocesseur. \\

Toute la communication avec le module se fait à travers les attribus de la class. Nous en mettons trois à disposition :
\begin{itemize}
	\item $auto\_config$ : Permet de lire et modifier le mode de fonctionnement du module. Il peut prendre deux valeurs : $0$ pour le mode manuel et $1$ pour le mode automatique.
	\item $frequency\_Hz$ : Permet de lire et modifier la fréquence en Hz du PWM si le mode manuel est activé. La valeur $0$ permette d'arrêter le PWM et tout autre valeur positive fixe la fréquence du PWM, 
	\item $temperature\_mC$ : Permet de lire la température du microprocesseur en millidegré celsius.
\end{itemize}

La mise en place des attributs se fait de la manière suivante :
\begin{lstlisting}[style=CStyle]
DEVICE_ATTR(frequency_Hz, 0664, show_frequency_Hz, store_frequency_Hz);
DEVICE_ATTR(auto_config, 0664, show_auto_config, store_auto_config);
DEVICE_ATTR(temperature_mC, 0444, show_temperature_mC, NULL);

static int __init my_module_init(void){
	/* ... */
	device_create_file(my_device, &dev_attr_frequency_Hz);
	device_create_file(my_device, &dev_attr_auto_config);
	device_create_file(my_device, &dev_attr_temperature_mC);
	/* ... */
}
\end{lstlisting}

Dans le code ci-dessus, les fonction $show\_*()$ et $store\_*()$ sont des fonctions qui permettent de lire et modifier les attributs. Elles sont appelées automatiquement par le système d'exploitation lorsqu'un utilisateur lit ou modifie un attribut. Elles sont définies selon le modèle suivant :

\begin{lstlisting}[style=CStyle]
ssize_t store_attr(struct device *dev, struct device_attribute *attr, const char *buf, size_t count){
	int new_value;
	sscanf(buf, "%d", &new_value);
	my_device_attribute.value = new_value;
	return count;
}

ssize_t show_attr(struct device *dev, struct device_attribute *attr, char *buf){
	sprintf(buf, "%d\n", my_device_attribute.value);
	return strlen(buf);
}
\end{lstlisting}

Etant donné que ces attributs permettent de contrôler le module, une logique supplémentaire est intégré dans les fonctions ci-dessus, afin de contrôler la cohérence des valeurs. Par exemple, la fréquence ne peut pas être modifié si le module est en mode auto ou être négative. \\

Le module utlise deux timers indépendants pour gérer le clignotement de la LED et la lecture de la température. Les deux timers sont périodiques, le premier est configuré avec la fréquence donnée par l'attribut et le second avec une période de 500 milisecondes. \\
Pour les configurer, nous utilisons une structure $timer\_list$ qui contient les informations nécessaires à la gestion du timer. Nous utilisons la fonction $setup\_timer()$ pour initialiser la structure avec la callback voulue et la fonction $mod\_timer()$ pour démarrer le timer. Ce timer a comme unité de temps les $jiffies$ qui est une unité de temps définie par le système d'exploitation et représente le temps entre deux ticks d'horloge successives. Voici l'example de configuration du timer de température :
\begin{lstlisting}[style=CStyle]
static struct timer_list timer_temprature;

void run_timer(struct timer_list *timer, unsigned long period_us){
	/* ... */
	mod_timer(timer, jiffies + usecs_to_jiffies(period_us));
}

void timer_temprature_callback(struct timer_list *timer){
	/* ... */
	// run timer again
	run_timer(&timer_fan, my_device_attribute.period_us_d2);		
}

static int __init my_module_init(void){
	/* ... */
    timer_setup(&timer_temprature, timer_temprature_callback, 0);
    run_timer(&timer_temprature, TEMP_PERIOD_US);
	/* ... */
}
\end{lstlisting}

Les callbacks des timers nous permettent de mettre à jour la temperature avec laquelle nous recalculons la nouvelle frequence du PWM et de créer un signal PWM avec un duty cycle de 50\% et la fréquence voulue. \\
Nos deux callbacks sont les suivantes :
\begin{lstlisting}[style=CStyle]
void timer_temprature_callback(struct timer_list *timer){
	struct thermal_zone_device *tzd;
	int temperature, ret, last_f;
	run_timer(&timer_temprature, TEMP_PERIOD_US);

	tzd = thermal_zone_get_zone_by_name("cpu-thermal");
	ret = thermal_zone_get_temp(tzd, &temperature);
	if(ret){
		pr_err("Pilotes Fan_ctl: Error in thermal_zone_get_temp\n");
		return;
	}
	my_device_attribute.temperature_mC = temperature;
	if(my_device_attribute.auto_config){
		last_f = my_device_attribute.frequency_Hz;
		if(temperature < TEMP_THR_1){
			my_device_attribute.frequency_Hz = TEMP_FRQ_1;
		}else if(temperature < TEMP_THR_2){
			my_device_attribute.frequency_Hz = TEMP_FRQ_2;
		}else if(temperature < TEMP_THR_3){
			my_device_attribute.frequency_Hz = TEMP_FRQ_3;
		}else{
			my_device_attribute.frequency_Hz = TEMP_FRQ_4;
		}
		my_device_attribute.period_us_d2 = S_IN_US / (2 * my_device_attribute.frequency_Hz);
		if(last_f == 0){
			run_timer(&timer_fan, my_device_attribute.period_us_d2);
		}
	}
}

void timer_fan_callback(struct timer_list *timer){
	static int state = 0;
	if(my_device_attribute.period_us_d2 == 0){
		state = 0;
	}else{
		run_timer(&timer_fan, my_device_attribute.period_us_d2);
		state = (state + 1) % 2;
	}
	gpio_set_value(GPIO_FAN, state);
}
\end{lstlisting}

La fonction $thermal\_zone\_get\_zone\_by\_name()$ permet de récupérer la zone thermique du CPU. La fonction $thermal\_zone\_get\_temp()$ permet de récupérer la température de la zone thermique, que nous stockons dans l'attribut $temperature\_mC$. \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DAEMON %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Daemon}\label{Daemon}
Un Daemon est un programme qui s'execute en arriere plan. 
Son objectif sera de gerer l'affichage des donnée sur l'ecran, tel que la temperature, frequence, et le mode de fonctionnement du module kernel.
Pour faire cela, il dispose de 2 interface de controle : \\
\begin{itemize}
	\item Les 3 bouton present sur la carte pour augmenter/diminuer la frequence, et changer le mode de fonctionnement.
	\item un IPC (Inter Process Communication) pour communiquer avec le module kernel. Dans notre cas, nous avons choisi d'utiliser un socket.
\end{itemize}

% Creation du daemon
La création du daemon se fait en plusieurs étapes : \\
TODO WRITE ...
Nous avons réutiliser le code fournis dans le cours comme point de départ pour la création du daemon. \\
\subsection{IPC}\label{IPC}
La communication entre un processus externe et le daemon se fait par un socket. 
Ce qui permet de controller la carte depuis n'importe quel ordinateur connecté au même réseau. 
L'initialisation du socket se fait dans la fonction \textit{void initSocket(int *mode, int *freq, pthread\_t *thread\_id, void* (*threadFunc)(void*))} qui est appelé dans la fonction \textit{main}.
La fonction prend un pointeur vers le mode, la frequence, et l'id du thread, ainsi qu'un pointeur vers la fonction qui sera executé par le thread. Afin de traiter les donnée recu.
Le socket est initialisé avec l'adresse IP de la carte, et le port 8080. \\

Comme nous étions libre pour le choix du protocole de communication, nous avons choisi d'utiliser un protocole simple, qui permet de controller le mode et la frequence du module kernel.
Le protocole est composé de 2 commandes : \\
\begin{itemize}
	\item M\textit{X} : Permet de choisir le mode de fonctionnement du module kernel. \textit{X} peut prendre 2 valeurs : 0 pour le mode manuel, et 1 pour le mode automatique.
	\item F\textit{XXX} : Permet de changer la frequence de clignotement de la LED. \textit{XXX} est un nombre entre 0 et 999.
\end{itemize}

Par exemple envoyer "M0", puis "F5" aura pour effet de mettre le mode manuel, et de mettre la frequence de clignotement à 5 Hz.

Voici le code du thread qui vas s'occuper de traiter les donnée recu par le socket : \\
\begin{lstlisting}[style=CStyle]
void *threadSocket(void *arg)
{
	int client_fd = 0;
	char buffer[SOCKET_BUFFER_SIZE] = {0};
	socketParamThread *param = (socketParamThread*) arg;
	int addresslen = sizeof(param->address);
	//listen on the socket
	if((client_fd = accept(param->server_fd, (struct sockaddr*)&param->address, ((socklen_t*) &addresslen))) < 0) {
		syslog(LOG_ERR, "accept");
		exit(EXIT_FAILURE);
	}
	syslog(LOG_INFO, "threadSocket started\n");
	while(1) {
		int valread = read(client_fd, buffer, SOCKET_BUFFER_SIZE);
		if (valread == 0) {
			syslog(LOG_INFO, "client disconnected\n");
			close(client_fd);
			client_fd = accept(param->server_fd, (struct sockaddr*)&param->address, ((socklen_t*) &addresslen));
		} else {
			if (buffer[0] == 'M') {
				*param->mode = buffer[1] - '0';
				writeMode(*param->mode);
				if (*param->mode == 0) {
					writeFreq(*param->freq);
				}
			} else if (buffer[0] == 'F') {
				*param->freq = atoi(&buffer[1]);
				writeFreq(*param->freq);
			}
			syslog(LOG_INFO, "received: %s\n", buffer);
		}
	}
	free(param);
	return NULL;
}
\end{lstlisting}
Le thread vas attendre qu'un client se connecte, puis il vas lire les donnée recu, et les traiter.
Si le client se déconnecte, le thread vas attendre qu'un nouveau client se connecte.
Le code ne permet pas à plusieur client de se connecter en même temps, mais il serais possible de le faire en créant un thread qui attend des connection, et qui créer un nouveau thread pour chaque client qui se connecte. \\


\subsection{Control des LED}\label{Leds}
L'acces a la LED par le daemon se fait par l'interface sysfs.
Pour cela, nous avons créer une fonction qui permet d'initialiser les LED, et une fonction qui permet de choisir l'etat de la led rouge.
Le prototype de la fonction d'écriture est : \textit{void writeLed(int value)}.
Voici le code d'initialisation des LED : \\
\begin{lstlisting}[style=CStyle]
void initLeds()
{
	int f = open(GPIO_UNEXPORT, O_WRONLY);
	write(f, LED, strlen(LED));
	close(f);

	// export pin to sysfs
	f = open(GPIO_EXPORT, O_WRONLY);
	write(f, LED, strlen(LED));
	close(f);

	// config pin
	f = open(GPIO_LED "/direction", O_WRONLY);
	write(f, "out", 3);
	close(f);
	g_led_fd = open(GPIO_LED "/value", O_WRONLY);
	syslog(LOG_INFO, "leds initialized\n");
}
\end{lstlisting}
Le code commence par exporter les LED, puis il configure les LED en sortie, en écrivant "out" dans le fichier direction.
Enfin, il ouvre le fichier value, qui permet d'écrire dans la LED. Le descripteur de fichier est stocké dans la variable globale \textit{g\_led\_fd}. \\

\subsection{Bouton}\label{Bouton}
Pour réaliser cette partie du TP, nous avons en partie réutilisé le code que nous avions écrit pour le rendu precedent.
Notre code utilise les epoll pour gérer les interruptions des boutons.
L'attente des evenement sur les bouton s'effectue dans le main avec la fonction \textit{epoll\_wait()}.

\section{Conclusion}




%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\printbibliography % Output the bibliography

%----------------------------------------------------------------------------------------

\end{document}