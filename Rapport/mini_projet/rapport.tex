%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% University/School Laboratory Report
% LaTeX Template
% Version 4.0 (March 21, 2022)
%
% This template originates from:
% https://www.LaTeXTemplates.com
%
% Authors:
% Vel (vel@latextemplates.com)
% Linux and Unix Users Group at Virginia Tech Wiki
%
% License:
% CC BY-NC-SA 4.0 (https://creativecommons.org/licenses/by-nc-sa/4.0/)
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%----------------------------------------------------------------------------------------
%	PACKAGES AND DOCUMENT CONFIGURATIONS
%----------------------------------------------------------------------------------------

\documentclass[
	a4paper, % Paper size, specify a4paper (A4) or letterpaper (US letter)
	10pt, % Default font size, specify 10pt, 11pt or 12pt
]{CSUniSchoolLabReport}


\addbibresource{sample.bib} % Bibliography file (located in the same folder as the template)

%----------------------------------------------------------------------------------------
%	REPORT INFORMATION
%----------------------------------------------------------------------------------------

\title{MA-CSEL \\ Conception système Embarqué Linux \\ Mini-Projet } % Report title

\author{Kirill \textsc{Goundiaev} \& Tanguy \textsc{Dietrich}} % Author name(s), add additional authors like: '\& James \textsc{Smith}'

\fancyhead[RE,LO]{Kirill Goundiaev \& Tanguy Dietrich}
\fancyhead[CE,CO]{\today}
\fancyhead[LE,RO]{MA-CSEL}

\fancyfoot[RE,LO]{MSE}
\fancyfoot[CE,CO]{\thepage} % this dicard page number dont touch
\fancyfoot[LE,RO]{HES-SO}
\date{\today} % Date of the report


% add image on the left top corner
% Definition of \maketitle
\makeatletter         
\def\@maketitle{
\raggedright
% \includegraphics[width = 60mm]{Figures/MSE.png}\\[8ex]
\includegraphics[width = 180mm]{Figures/ImageTitle.png}\\[8ex]
\begin{center}{}
{\Huge \@title }\\[4ex] 
{\Large  \@author}\\[4ex] 
\@date\\[8ex]
% \includegraphics[width = 40mm]{Figures/HESSO.png}
\end{center}}
\makeatother

%----------------------------------------------------------------------------------------

\begin{document}

\maketitle % Insert the title, author and date using the information specified above

% add an image
\begin{figure}[H] % Example image
\center{\includegraphics[width=0.35\linewidth]{EMbeddedLinuxLogo}}
% \caption{Example image.}
\label{fig:speciation}
\end{figure}


%  to make a guard page
\newpage

% generate the summary table
\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRO %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}\label{Introduction}
Le projet est composé de 2 parties : \\
\begin{itemize}
	\item Un module kernel qui permet de controler la frequence du processeur, et de changer le mode de fonctionnement du module kernel. Et il met a disposition les informations sur la temperature du CPU.
	\item Un daemon qui permet d'afficher les informations sur l'ecran, et de controler le module kernel.
\end{itemize}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MODULE KERNEL %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Module Kernel}\label{ModuleKernel}
TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% DAEMON %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Daemon}\label{Daemon}
Un Daemon est un programme qui s'execute en arriere plan. 
Son objectif sera de gerer l'affichage des donnée sur l'ecran, tel que la temperature, frequence, et le mode de fonctionnement du module kernel.
Pour faire cela, il dispose de 2 interface de controle : \\
\begin{itemize}
	\item Les 3 bouton present sur la carte pour augmenter/diminuer la frequence, et changer le mode de fonctionnement.
	\item un IPC (Inter Process Communication) pour communiquer avec le module kernel. Dans notre cas, nous avons choisi d'utiliser un socket.
\end{itemize}

Nous avons réutiliser le code fournis dans le cours comme point de départ pour la création du daemon. \\

Nous avons repartie le code de notre programme dans differentes librairies afin de le rendre plus lisible, voici les fichier qui le compose, et leux contenue : \\
\begin{itemize}
	\item \textit{main.c}\\
	Ce fichier contien le main de notre programme, il initialise le daemon et contient le thread de reception des message du socket.
	\item \textit{daemonfanlib.c/h}\\
	Cette librairie contient les fonction necessaire a l'initialisation du socket et de la creation du daemon. Le constante qui indique le port du socket.
	\item \textit{gpio\_utility.c/h}\\
	Cette librairies permet d'acceder au GPIO de la carte, ainsi qu'au information fournis par le module kernel. le header contient divers constante qui permettent de definir les GPIO utilisé.
	\item \textit{ssd1306.c/h}\\
	Cette librairies fournis les fonction utiles à l'utilisation de l'écran. Cette librairies nous à été fournis dans le cours.

\end{itemize}
\subsection{IPC}\label{IPC}
La communication entre un processus externe et le daemon se fait par un socket. 
Ce qui permet de controller la carte depuis n'importe quel ordinateur connecté au même réseau. 
L'initialisation du socket se fait dans la fonction \textit{void initSocket(int *mode, int *freq, pthread\_t *thread\_id, void* (*threadFunc)(void*))} qui est appelé dans la fonction \textit{main}.
La fonction prend un pointeur vers le mode, la frequence, et l'id du thread, ainsi qu'un pointeur vers la fonction qui sera executé par le thread. Afin de traiter les donnée recu.
Le socket est initialisé avec l'adresse IP de la carte, et le port 8080. \\

Comme nous étions libre pour le choix du protocole de communication, nous avons choisi d'utiliser un protocole simple, qui permet de controller le mode et la frequence du module kernel.
Le protocole est composé de 2 commandes : \\
\begin{itemize}
	\item M\textit{X} : Permet de choisir le mode de fonctionnement du module kernel. \textit{X} peut prendre 2 valeurs : 0 pour le mode manuel, et 1 pour le mode automatique.
	\item F\textit{XXX} : Permet de changer la frequence de clignotement de la LED. \textit{XXX} est un nombre entre 0 et 999.
\end{itemize}

Par exemple envoyer "M0", puis "F5" aura pour effet de mettre le mode manuel, et de mettre la frequence de clignotement à 5 Hz.

Voici le code du thread qui vas s'occuper de traiter les donnée recu par le socket : \\
\begin{lstlisting}[style=CStyle]
static void *threadSocket(void *arg)
{
	int client_fd = 0;
	char buffer[SOCKET_BUFFER_SIZE] = {0};
	// get the parameters
	socketParamThread *param = (socketParamThread*) arg;
	int addresslen = sizeof(param->address);
	//listen on the socket
	if((client_fd = accept(param->server_fd, (struct sockaddr*)&param->address, ((socklen_t*) &addresslen))) < 0) {
		syslog(LOG_ERR, "accept");
		exit(EXIT_FAILURE);
	}

	syslog(LOG_INFO, "threadSocket started\n");
	while(1) {
		int valread = read(client_fd, buffer, SOCKET_BUFFER_SIZE);
		if (valread == 0) {
			syslog(LOG_INFO, "client disconnected\n");
			close(client_fd);
			client_fd = accept(param->server_fd, (struct sockaddr*)&param->address, ((socklen_t*) &addresslen));
		} else {
			if (buffer[0] == 'M') {
				*param->mode = buffer[1] - '0';
				writeMode(*param->mode);
				if (*param->mode == 0) {
					writeFreq(*param->freq);
				}
			} else if (buffer[0] == 'F') {
				*param->freq = atoi(&buffer[1]);
				writeFreq(*param->freq);
			}
			syslog(LOG_INFO, "received: %s\n", buffer);
		}
	}
	free(param);
	return NULL;
}
\end{lstlisting}
Le thread vas attendre qu'un client se connecte, puis il vas lire les donnée recu, et les traiter.
Si le client se déconnecte, le thread vas attendre qu'un nouveau client se connecte.
Le code ne permet pas à plusieur client de se connecter en même temps, mais il serais possible de le faire en créant un thread qui attend des connection, et qui créer un nouveau thread pour chaque client qui se connecte. \\


\subsection{Control des LED}\label{Leds}
L'acces a la LED par le daemon se fait par l'interface sysfs.
Pour cela, nous avons créer une fonction qui permet d'initialiser les LED, et une fonction qui permet de choisir l'etat de la led rouge.
Le prototype de la fonction d'écriture est : \textit{void writeLed(int value)}.
Voici le code d'initialisation des LED : \\
\begin{lstlisting}[style=CStyle]
void initLeds()
{
	int f = open(GPIO_UNEXPORT, O_WRONLY);
	write(f, LED, strlen(LED));
	close(f);

	// export pin to sysfs
	f = open(GPIO_EXPORT, O_WRONLY);
	write(f, LED, strlen(LED));
	close(f);

	// config pin
	f = open(GPIO_LED "/direction", O_WRONLY);
	write(f, "out", 3);
	close(f);
	g_led_fd = open(GPIO_LED "/value", O_WRONLY);
	syslog(LOG_INFO, "leds initialized\n");
}
\end{lstlisting}
Le code commence par exporter les LED, puis il configure les LED en sortie, en écrivant "out" dans le fichier direction.
Enfin, il ouvre le fichier value, qui permet d'écrire dans la LED. Le descripteur de fichier est stocké dans la variable globale \textit{g\_led\_fd}. \\
Pour finir un simple appel a la fonction \textit{void writeLed(int value)} permet de changer l'etat de la LED rouge.


\subsection{Bouton}\label{Bouton}
Pour réaliser cette partie du TP, nous avons en partie réutilisé le code que nous avions écrit pour le rendu precedent.
Notre code utilise les epoll pour gérer les interruptions des boutons.
afin de rendre le code main plus lisible, nous avons écrit une fonction \textit{int initButtonsAndTimer()} qui permet d'initialiser les boutons, et un timer pour etre utiliser avec les epoll.
Cette fonction fais appel au fonction epoll\_create1(), epoll\_ctl(), et timerfd\_create() pour créer les epoll et le timer.
puis elle retourne un descripteur de fichier qui permet de lire les evenement sur les boutons, et le timer.
\begin{lstlisting}[style=CStyle]
// init the buttons S1, S2 and S3, and the timer
epfd = initButtonsAndTimer();
\end{lstlisting}
L'attente des evenement sur les bouton s'effectue dans le main avec la fonction \textit{epoll\_wait()}.
Voici un extrait du code main, qui permet de lire les evenement sur les boutons : \\
\begin{lstlisting}[style=CStyle]
while (1) {
	struct epoll_event event_arrived[NUM_EVENTS];
	syslog(LOG_INFO, "waiting for event epoll\n");
	writeLed(LED_OFF);
	int nr = epoll_wait(epfd, event_arrived, NUM_EVENTS, -1);
	syslog(LOG_INFO, "event arrived\n");
	if (nr == -1) {
		// printf("error epoll_wait: %s\n", strerror(errno));
		syslog(LOG_ERR, "epoll_wait");
		exit(EXIT_FAILURE);
	}
	for(int i = 0; i < nr; i++){
		my_context *ctx = event_arrived[i].data.ptr;

		switch (ctx->ev){
		case EV_BTN_1: // increase frequence
			syslog(LOG_INFO, "button 1 pressed\n");
			if(ctx->first_done == 0){
				ctx->first_done = 1;
				break;
			}
			freq++;
			writeFreq(freq); // will fail if in auto mode
			writeLed(LED_ON);
		break;
		// ...
\end{lstlisting}

Dans le epoll, nous avons aussi ajouté le timer, qui permet de raffraichir l'affichage de la temperature, et de la frequence en mode automatique.
Le timer est initialisé avec une periode de 200ms, il est possible de le modifier dans le fichier gpio\_utility.h, en modifiant la constante \textit{DEFAULT\_PERIOD}.
Voici un extrait de la gestion de l'evevement timer : \\
\begin{lstlisting}[style=CStyle]
case EV_TIMER:
// read the actual mode
syslog(LOG_INFO, "timer expired\n");
mode = readMode(); 
updateTempCPU();
if(mode == 1) // if in auto mode
{
	// read the actual freq
	freq = readFreq();
	// show it on the screen
	writeLCDFreq(freq); 
}
else // if in manual mode
{
	// syslog(LOG_INFO, "manual mode\n");
}
break;
\end{lstlisting}

\subsection{Concurence}
Comme notre programme est multithreadé (thread socket et thread main), il est possible d'avoir des problèmes de concurence. Pour eviter cela nous avons ajouter un mutex ces les commande envoyé au LCD.
Les variable de mode et de frequence sont aussi partagé, et peuvent etre modifié par le thread socket, et par le main. mais dans ce cas, les risques sont assez faible, il faudrait qu'un requette soit envoyé au moment au quelqun écrit sur le socket.
Exemple de protection dans la fonction \textit{void writeLCDFreq(int freq)} : \\
\begin{lstlisting}[style=CStyle]
	

\end{lstlisting}

\section{Conclusion}




%----------------------------------------------------------------------------------------
%	BIBLIOGRAPHY
%----------------------------------------------------------------------------------------

\printbibliography % Output the bibliography

%----------------------------------------------------------------------------------------

\end{document}